<html>
	<head>
		<title>TBD</title>


	</head>
	<body>

		<canvas id="canvas" width="600" height="600" style="border:1px solid #000000;">
		</canvas>

		<script>
			// Variables
			//--------------------------------------------------------
			var RADIUS = 20; //radius of the circles
			var MAX_SPEED = 10;//max dx or dy of a circle
			var MAX_EXPLO_SIZE = 40; //explosion go untill this size
			var START_HEALTH = 150;
			var INIT_COUNT = 17;

			// associate html elements
			var canvas = document.getElementById('canvas');
			var ctx = canvas.getContext('2d');

			var circles_alive = []; //store drawn circles
			var circles_death = null;
			var score = 0;

			// Basic Funcions
			//--------------------------------------------------------
			//draw circles
			var drawCircle = function(circle){
				ctx.fillStyle = circle.color;
				
				ctx.beginPath();

				ctx.arc(circle.x,
					circle.y,
					circle.r, 
					0, Math.PI*2
				);
				
				ctx.closePath();
				ctx.fill();
			};

			//returns a random hex color
			function getRandomColor() {
				//stolen with pride from http://stackoverflow.com/questions/1484506/random-color-generator-in-javascript
			    var letters = '0123456789ABCDEF'.split('');
			    var color = '#';
			    for (var i = 0; i < 6; i++ ) {
			        color += letters[Math.floor(Math.random() * 16)];
			    }
			    return color;
			}

			//place initcount random circles on the field			
			var initCircles = function(initCount){
				for (i = 0; i < initCount; i++){

					//location
					var x = Math.round(
						RADIUS + 
						(
							Math.random() * 
							(canvas.width - 2*RADIUS)
						)
					);
					var y = Math.round(
						RADIUS + 
						(
							Math.random() * 
							(canvas.height - 2*RADIUS)
						)
					);

					//speeds
					var dx = 0;
					var dy = 0;
					while (dx == 0 || dy == 0){
						dx = Math.round(Math.random() * MAX_SPEED * 2) - MAX_SPEED;
						dy = Math.round(Math.random() * MAX_SPEED * 2) - MAX_SPEED;
					}

					//store
					circle = {
						'x' : x ,
						'y' : y ,
						'dx': dx,
						'dy': dy,
						'r' : RADIUS,
						'health': START_HEALTH,
						'color' : getRandomColor(),
						'score' : 100
					};
					
					circles_alive.push(circle);

					//draw
					drawCircle(circle);
				}
			}

			//move the circle across the canvas
			var drawAliveCircles = function(){
				//clear board
				ctx.clearRect(0,0,canvas.width,canvas.height);

				//re-add circles at new position
				for (i = 0; i < circles_alive.length; i++){
					circle = circles_alive[i];

					//referenced => new x & y are auto-saved in array :D
					circle.x = circle.x + circle.dx;
					circle.y = circle.y + circle.dy;
					
					//outside canvas?
					// fix x;y coordinates & change direction
					if (circle.x <= circle.r){
						circle.x = circle.r - (circle.x - circle.r);
						circle.dx = - circle.dx;

					} else if (circle.x + circle.r >= canvas.width){
						circle.x  = circle.x - (circle.x + circle.r - canvas.width);
						circle.dx = - circle.dx;

					}

					if (circle.y <= circle.r){
						circle.y = circle.r - (circle.y - circle.r);
						circle.dy = - circle.dy;

					} else if (circle.y + circle.r >= canvas.height){
						circle.y  = circle.y - (circle.y + circle.r - canvas.height);
						circle.dy = - circle.dy;
					}

					//draw
					drawCircle(circle);
				}
			}

			//r+= 2 when exploding
			var drawDeathCircles = function(){
				if (circles_death){

					for (i = 0; i < circles_death.length; i++){

						death_circle = circles_death[i];

						if (death_circle.r < MAX_EXPLO_SIZE && death_circle.health > 0){
							death_circle.r += 2;
						}

						drawCircle(death_circle);
					}
				}
			}
			
			//check for collisions & update health stuffz
			var checkCollisions = function(){
				if (circles_death){
					
					var i = 0;
					while (i < circles_death.length){
						death_circle = circles_death[i];

						var j = 0;
						while ( j < circles_alive.length){
						
							alive_circle = circles_alive[j];
						
							//distance between circles
							var dist = Math.sqrt(
									(death_circle.x - alive_circle.x) 
									* 
									(death_circle.x - alive_circle.x)
									
								+
								
									(death_circle.y - alive_circle.y) 
									* 
									(death_circle.y - alive_circle.y)
							);

							if ( dist <= alive_circle.r + death_circle.r){ //collision
								
								alive_circle.r += 2;
								alive_circle.score = death_circle.score * 2;
								
								score += alive_circle.score;

								//move to other array
								circles_death.push(alive_circle);
								circles_alive.splice(j,1); //remove

								console.log(score);

							} else {
								j++; //only increase j if no items are removed !
							}
						}


						if (death_circle.health > 0){							
							death_circle.health -= 2;	
						} else {
							death_circle.r--;
						}

						if (death_circle.r <= 0 && death_circle.health <= 0){
							//remove
							circles_death.splice(i,1);
						} else {
							//move when nothing is removed from array
							i++;
						}
					}
				}
			}



			// Start game
			//--------------------------------------------------------
			initCircles(INIT_COUNT);
			window.setInterval(function(){
				drawAliveCircles();
				drawDeathCircles();
				checkCollisions();
			},30);

			// Event listener
			//--------------------------------------------------------
			canvas.addEventListener('click', function(){
				if (!circles_death){
					circle = {
						'x' : event.pageX - canvas.offsetLeft, //correct for canvas offset
						'y' : event.pageY - canvas.offsetTop, 
						'dx': 0,
						'dy': 0,
						'r' : 10, 
						'health': START_HEALTH,
						'color' : "#000000",
						'score' : 100
					};

					drawCircle(circle);

					circles_death = [circle];

					score += circle.score;
					console.log(score);
				}
				/*
				drawAliveCircles();
				drawDeathCircles();
				checkCollisions();
				*/

			}, false);
		</script>
	</body>
</html>